# 댓글(생성, 수정, 삭제) + 회원가입/로그인 패턴 개선
1. 처음 설계한 API 명세서에 변경사항이 있었나요? 변경 되었다면 어떤 점 때문 일까요? 첫 설계의 중요성에 대해 작성해 주세요!
A : 회원가입/로그인 구현에서 기존에 변경된 것은 없었고, 새로 추가된 댓글 기능을 위한 api가 추가되는 변경사항만 존재했다.

2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되셨나요?
A : ERD를 보고 Entity간에 연관관계를 이해와 구현을 쉽게할 수 있었다.

3. JWT를 사용하여 인증/인가를 구현 했을 때의 장점은 무엇일까요?
A : 1. 사용자 인증에 필요한 모든 정보는 JWT 토큰에 포함되어 있어서 별도의 저장소가 필요없다.
    2. 쿠키를 전달하지 않으므로 쿠키로 인해 발생하는 취약점이 사라진다.
    3. 트래픽에 대한 부담이 적다 - 1번 과정에 의해서
    4. REST 서비스로 제공 가능하다.
    5. Token의 만료기간 설정으로 자동 관리할 수 있다.

4. 반대로 JWT를 사용한 인증/인가의 한계점은 무엇일까요?
A : 1. 토큰의 페이로드에 principal, credients, authorities 3종류를 담는데, 정보의 길이가 커지면
        토큰의 길이가 길어져 네트워크에 부하가 올수 있다.
    2. Payload가 암호화된 것이 아니라 BASE64로 인코딩된 것이기 때문에 payload 탈취시 디코딩하여 정보의 노출가능
    3. Stateless로 JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 임의로 삭제가 불가능하다
    4. JWT 토큰을 클라이언트 측에 저장하는 것 = 보안성문제

5. 댓글이 달려있는 게시글을 삭제하려고 할 때 무슨 문제가 발생할까요? JPA가 아닌 Database 테이블 관점에서 해결방법이 무엇일까요?
A : Database의 CASECADE 옵션을 통해 연결된 데이터가 같이 삭제될 수 있도록하는 방법이 있는 것으로 안다.

6. 5번과 같은 문제가 발생했을 때 JPA에서는 어떻게 해결할 수 있을까요?
A : 아직 4주차 강의를 다 듣지 못해서 정확하게는 알지 못하지만, JPA에서도 DB의 CASECADE와 같은 기능을
    하는 애너테이션 또는 설정이 존재하지 않을까 예상해본다.
    검색하여 알아본 것으로 CASECADE 설정 또는 orphanRemoval옵션으로 고아객체를 자동으로 제거해주는 방법이 있다.
    Casecade.ALL과 orphanRemovel=true설정을 통해 부모 엔티티와 자식 엔티티의 생명주기를 함께만들어 관리하는 방법을 이용한다.
7. IoC / DI 에 대해 간략하게 설명해 주세요!
A : IoC : 제어의 역전으로 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아닌, 외부에서 결정되는 것을 의미한다.
          클래스 간에 의존관계를 최소화하여 한 클래스에 변경이 있더라도 다른 클래스에 영향을 안주도록 하는 것
    DI : 구체적인 의존 오브젝트와 그것을 사용할 주체, 클라이언트 오브젝트를 런타임 시에 연결해주는 작업으로 모듈 간의 결합도를 낮추어
          제3자에 의해 관계를 맺도록 도움을 받는 것


# 회원가입 & 로그인 구현 시
1. 처음 설계한 API와 ERD에 변경사항이 있나요? 변경되었다면 어떤 점 때문인가 첫 설계의 중요성에 대해 생각해보자
A : 기존에는 메모의 생성, 수정, 삭제에 별도의 password를 요구하였는데 JWT 토큰 인증/인가 방식을 사용하여 사용자를 인증하므로
    password가 필요없어져서 request에 password가 빠진 대신에 request Header에 JWT 토큰 정보가 들어온다.
    그리고 회원가입, 로그인을 위한 api가 추가되었다.

2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되었는가?
A : ERD를 먼저 설계한 후 Entity를 개발하면 Entity구성을 쉽게 할 수 있다는 장점이 있는 것 같다.

3. JWT를 사용하여 인증/인가를 구현했을 때의 장점은 무엇인가?
A : 1. 사용자 인증에 필요한 모든 정보는 토큰에 포함되어 있기 때문에 별도의 인증 저장소가 필요가 없다.
    2. 쿠키를 전달하지 않으므로 쿠키로 인해 발생하는 취약점이 사라진다.
    3. 트래픽에 대한 부담이 적다. = 1번 과정때문에
    4. REST 서비스로 제공 가능하다 - HTTP와 XML을 이용하여 데이터를 주고받을 수 있다.
    5. Token의 만료기간 설정으로 자동으로 관리된다.

4. 반대로 JWT를 사용한 인증/인가의 한계점은 무언인가?
A : 1. 토큰의 페이로드(payload)에 principal, credients, authorities 3종류를 담고 있는데, 정보가 많아질 수록
        토큰의 길이가 길어져 네트워크에 부하가 올 수 있다.
    2. Payload가 암호화된 것이 아니라 BASE64로 인코딩된 것이기 때문에 payload 탈취시 디코딩하여 정보를 볼 수 있다.
    3. Stateless로 JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 임의로 삭제하는 것이 불가능하다 => 만료기간 설정
    4. JWT 토큰을 클라이언트 측에 저장한다. = 서버에 저장하지 않는다.


# CRUD 기능 구현 시
1. 수정, 삭제 API의 request를 어떤 방식으로 사용했나요? (param, query, body)
A: 공통적으로 id의 경우, param을 이용하여 @PathVariable을 통해 url로 전달하였다.
수정 request의 경우, 사용자로부터 입력받는 데이터가 Memo Entity 생성자와 일치하기 때문에 JSON형태로 받아와
객체로 자동 변환하여 만들어주는 @RequestBody 형태로 사용하였다.
삭제 request의 경우, password만을 넘겨주기 때문에 간단한 Requestparam이나 PathVaraibleMemo을 고려했지만
패스워드가 같은 중요 데이터 값을 url에 표시하는 것이 좋지않아서 json body로 데이터를 넘기도록 하였다.
Entity객체에서 password만을 생성하는 객체가 아니므로, 별도의 Map 객체로 받아서 값을 받아왔다.


2. 어떤 상황에 어떤 방식의 request를 써야하나?
A: 데이터를 조회하는 경우 GET, 데이터를 추가하는 경우 POST, 데이터를 수정하는 경우 PUT, 데이터를 삭제하는 경우 DELETE

3. RESTful한 API를 설계하였나? 어떤 부분이 그렇고, 어떤 부분이 그렇지 않은지
A: Controller, Service, Repository로 3계층을 나누어 Controller는 데이터의 전달, Service는 데이터의 가공, Repository는 데이터베이스의 관리를
담당할 수 있도록 기능들을 분리하여 코드를 작성하였다. 요청받는 url의 형식을 통일하였고, 요청에 맞는 API를 지정하였다.

4. 적절한 관심사 분리를 적용하였나요? (controller, Repository, Service)
A: controller에는 데이터의 전달을 담당하는 기능만, Service에는 데이터의 가공, 로직 수행을 위한 코드만, Repository에는 데이터베이스에서
처리할 수 있는 기능으로 분리하여 코드를 작성하였다.

5. API 명세서
api 명세 이미지 첨부
