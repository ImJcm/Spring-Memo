# 회원가입 & 로그인 구현 시
1. 처음 설계한 API와 ERD에 변경사항이 있나요? 변경되었다면 어떤 점 때문인가 첫 설계의 중요성에 대해 생각해보자
A : 기존에는 메모의 생성, 수정, 삭제에 별도의 password를 요구하였는데 JWT 토큰 인증/인가 방식을 사용하여 사용자를 인증하므로
    password가 필요없어져서 request에 password가 빠진 대신에 request Header에 JWT 토큰 정보가 들어온다.
    그리고 회원가입, 로그인을 위한 api가 추가되었다.

2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되었는가?
A : ERD를 먼저 설계한 후 Entity를 개발하면 Entity구성을 쉽게 할 수 있다는 장점이 있는 것 같다.

3. JWT를 사용하여 인증/인가를 구현했을 때의 장점은 무엇인가?
A : 1. 사용자 인증에 필요한 모든 정보는 토큰에 포함되어 있기 때문에 별도의 인증 저장소가 필요가 없다.
    2. 쿠키를 전달하지 않으므로 쿠키로 인해 발생하는 취약점이 사라진다.
    3. 트래픽에 대한 부담이 적다. = 1번 과정때문에
    4. REST 서비스로 제공 가능하다 - HTTP와 XML을 이용하여 데이터를 주고받을 수 있다.
    5. Token의 만료기간 설정으로 자동으로 관리된다.

4. 반대로 JWT를 사용한 인증/인가의 한계점은 무언인가?
A : 1. 토큰의 페이로드(payload)에 principal, credients, authorities 3종류를 담고 있는데, 정보가 많아질 수록
        토큰의 길이가 길어져 네트워크에 부하가 올 수 있다.
    2. Payload가 암호화된 것이 아니라 BASE64로 인코딩된 것이기 때문에 payload 탈취시 디코딩하여 정보를 볼 수 있다.
    3. Stateless로 JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 임의로 삭제하는 것이 불가능하다 => 만료기간 설정
    4. JWT 토큰을 클라이언트 측에 저장한다. = 서버에 저장하지 않는다.


# CRUD 기능 구현 시
1. 수정, 삭제 API의 request를 어떤 방식으로 사용했나요? (param, query, body)
A: 공통적으로 id의 경우, param을 이용하여 @PathVariable을 통해 url로 전달하였다.
수정 request의 경우, 사용자로부터 입력받는 데이터가 Memo Entity 생성자와 일치하기 때문에 JSON형태로 받아와
객체로 자동 변환하여 만들어주는 @RequestBody 형태로 사용하였다.
삭제 request의 경우, password만을 넘겨주기 때문에 간단한 Requestparam이나 PathVaraibleMemo을 고려했지만
패스워드가 같은 중요 데이터 값을 url에 표시하는 것이 좋지않아서 json body로 데이터를 넘기도록 하였다.
Entity객체에서 password만을 생성하는 객체가 아니므로, 별도의 Map 객체로 받아서 값을 받아왔다.


2. 어떤 상황에 어떤 방식의 request를 써야하나?
A: 데이터를 조회하는 경우 GET, 데이터를 추가하는 경우 POST, 데이터를 수정하는 경우 PUT, 데이터를 삭제하는 경우 DELETE

3. RESTful한 API를 설계하였나? 어떤 부분이 그렇고, 어떤 부분이 그렇지 않은지
A: Controller, Service, Repository로 3계층을 나누어 Controller는 데이터의 전달, Service는 데이터의 가공, Repository는 데이터베이스의 관리를
담당할 수 있도록 기능들을 분리하여 코드를 작성하였다. 요청받는 url의 형식을 통일하였고, 요청에 맞는 API를 지정하였다.

4. 적절한 관심사 분리를 적용하였나요? (controller, Repository, Service)
A: controller에는 데이터의 전달을 담당하는 기능만, Service에는 데이터의 가공, 로직 수행을 위한 코드만, Repository에는 데이터베이스에서
처리할 수 있는 기능으로 분리하여 코드를 작성하였다.

5. API 명세서
api 명세 이미지 첨부
