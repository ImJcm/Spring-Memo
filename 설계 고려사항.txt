# 게시글, 댓글 좋아요 기능 및 예외처리 & Spring Security
1. Spring Security를 적용했을 때 어떤 점이 도움이 되셨나요?
Spring Security를 적용하지 않을 때 JWT 토큰의 값을 api마다 검증 과정을 거쳐야 했지만, Spring Security를 적용하여
Spring Framework가 보안적인 기능을 제공하고 인증/인가 과정을 DispatcherServlet 이전에 Filter를 통해 처리가 가능하다는 점

2. Spring Security를 사용하지 않는다면 어떻게 인증/인가를 효율적으로 처리할 수 있을까요?
쿠키, 세션을 이용하여 인증/인가 처리하는 방법의 경우 서버 측에서 DB에서 사용자 정보를 로드하는 과정과 서버 측 별도의 세션 저장소가
필요하기 때문에 JWT(JSON WEB Token) 방식에 비해 효율적이지 못하다.
JWT 토큰 인증 방식을 사용하여 인증 요청시 username을 기반으로 JWT 토큰을 만들고 클라이언트에게 반환하고 클라이언트에서 서버에
요청 시 JWT 토큰 값을 request header로 넘겨주어 인증된 사용자라는 것을 증명하고 인가를 받는다. 이때 jwt 토큰을 검증하여 인증
상태를 확인하는 방법으로 spring security 방식을 사용하지 않을때는 효율적인 방법이라고 생각한다.

3. AOP에 대해 설명해 주세요!
AOP(Aspect Oriented Programing) : 관점 지향 프로그래밍으로 로직을 기준으로 핵심 기능과 부가 기능을 나누어 관점별로 각각 모듈화하는 것을 의미한다.
공통적으로 사용하는 기능들을 핵심 기능과 분리하여 재사용을 목적으로 하는 프로그래밍 방법이다.

AOP의 특징으로 proxy 패턴 기반의 aop 구현체, 프록시 객체를 접근 제어 및 부가기능을 추가하기 위해서 사용하며, 스프링 bean 객체에만
aop를 적용 가능하다.

4. RefreshToken 적용에 대한 장/단점을 작성해 주세요! 적용해 보지 않으셨다면 JWT를 사용하여 인증/인가를 구현 했을 때의 장/단점에 대해 숙련주차의 답변을 Upgrade 하여 작성해 주세요!
쿠키-세션에서 발생하는 별도의 세션 저장소와 내부 트래픽으로 효율적이지 못한 방법에서 JWT 방법으로 JWT 검증만을 통해 내부 트래픽을 줄일 수 있다는 장점이 있고,
spring Security와 함께 사용하여 server내부에서 jwt 검증하는 것이 아닌 DispatcherServlet 앞단에서 filter를 통해 인증/인가를 전역적으로 사용할 수 있어서
서버 내부의 인증이 필요한 기능에 추가적인 로직을 요구하지 않는다는 점이 있다. 또한 Spring Security를 사용하기 때문에 개발자가 보안로직을 수행하는 기능들을 만들 필요없이
제공되는 기능을 사용하여 보안적인 인증/인가 기능을 이용할 수 있다.

Spring Security를 사용한다고 해서 클라이언트에 저장되는 JWT 토큰의 payload가 노출되는 문제는 해결할 수 없다는 점과 기존의 JWT 토큰의
단점이 해결되지 않는다.
- 토큰의 정보 길이가 길어지면 네트워트 부하, JWT 내의 payload 디코딩 가능, stateless 상태이기 때문에 임의의 삭제가 불가능, JWT 토큰을 클라이언트에 저장하는 보안성문제

5. 즉시로딩 / 지연로딩에 대해 설명해 주세요!
지연로딩(FetchType=LAZY) : 필요한 시점에 정보를 가져오는 방법으로 많은 양의 데이터를 조회할 때 효율적이다.
지연로딩(FetchType=EAGER) : 조회할 때 연관된 모든 Entity의 정보를 즉시 가져오는 방법으로 적은 양의 데이터를 조회할 때 효율적이다.

# 댓글(생성, 수정, 삭제) + 회원가입/로그인 패턴 개선
1. 처음 설계한 API 명세서에 변경사항이 있었나요? 변경 되었다면 어떤 점 때문 일까요? 첫 설계의 중요성에 대해 작성해 주세요!
A : 회원가입/로그인 구현에서 기존에 변경된 것은 없었고, 새로 추가된 댓글 기능을 위한 api가 추가되는 변경사항만 존재했다.

2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되셨나요?
A : ERD를 보고 Entity간에 연관관계를 이해와 구현을 쉽게할 수 있었다.

3. JWT를 사용하여 인증/인가를 구현 했을 때의 장점은 무엇일까요?
A : 1. 사용자 인증에 필요한 모든 정보는 JWT 토큰에 포함되어 있어서 별도의 저장소가 필요없다.
    2. 쿠키를 전달하지 않으므로 쿠키로 인해 발생하는 취약점이 사라진다.
    3. 트래픽에 대한 부담이 적다 - 1번 과정에 의해서
    4. REST 서비스로 제공 가능하다.
    5. Token의 만료기간 설정으로 자동 관리할 수 있다.

4. 반대로 JWT를 사용한 인증/인가의 한계점은 무엇일까요?
A : 1. 토큰의 페이로드에 principal, credients, authorities 3종류를 담는데, 정보의 길이가 커지면
        토큰의 길이가 길어져 네트워크에 부하가 올수 있다.
    2. Payload가 암호화된 것이 아니라 BASE64로 인코딩된 것이기 때문에 payload 탈취시 디코딩하여 정보의 노출가능
    3. Stateless로 JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 임의로 삭제가 불가능하다
    4. JWT 토큰을 클라이언트 측에 저장하는 것 = 보안성문제

5. 댓글이 달려있는 게시글을 삭제하려고 할 때 무슨 문제가 발생할까요? JPA가 아닌 Database 테이블 관점에서 해결방법이 무엇일까요?
A : Database의 CASCADE 옵션을 통해 연결된 데이터가 같이 삭제될 수 있도록하는 방법이 있는 것으로 안다.

6. 5번과 같은 문제가 발생했을 때 JPA에서는 어떻게 해결할 수 있을까요?
A : 아직 4주차 강의를 다 듣지 못해서 정확하게는 알지 못하지만, JPA에서도 DB의 CASCADE와 같은 기능을
    하는 애너테이션 또는 설정이 존재하지 않을까 예상해본다.
    검색하여 알아본 것으로 CASECADE 설정 또는 orphanRemoval옵션으로 고아객체를 자동으로 제거해주는 방법이 있다.
    Cascade.ALL과 orphanRemovel=true설정을 통해 부모 엔티티와 자식 엔티티의 생명주기를 함께만들어 관리하는 방법을 이용한다.

7. IoC / DI 에 대해 간략하게 설명해 주세요!
A : IoC : 제어의 역전으로 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아닌, 외부에서 결정되는 것을 의미한다.
          클래스 간에 의존관계를 최소화하여 한 클래스에 변경이 있더라도 다른 클래스에 영향을 안주도록 하는 것
    DI : 구체적인 의존 오브젝트와 그것을 사용할 주체, 클라이언트 오브젝트를 런타임 시에 연결해주는 작업으로 모듈 간의 결합도를 낮추어
          제3자에 의해 관계를 맺도록 도움을 받는 것


# 회원가입 & 로그인 구현 시
1. 처음 설계한 API와 ERD에 변경사항이 있나요? 변경되었다면 어떤 점 때문인가 첫 설계의 중요성에 대해 생각해보자
A : 기존에는 메모의 생성, 수정, 삭제에 별도의 password를 요구하였는데 JWT 토큰 인증/인가 방식을 사용하여 사용자를 인증하므로
    password가 필요없어져서 request에 password가 빠진 대신에 request Header에 JWT 토큰 정보가 들어온다.
    그리고 회원가입, 로그인을 위한 api가 추가되었다.

2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되었는가?
A : ERD를 먼저 설계한 후 Entity를 개발하면 Entity구성을 쉽게 할 수 있다는 장점이 있는 것 같다.

3. JWT를 사용하여 인증/인가를 구현했을 때의 장점은 무엇인가?
A : 1. 사용자 인증에 필요한 모든 정보는 토큰에 포함되어 있기 때문에 별도의 인증 저장소가 필요가 없다.
    2. 쿠키를 전달하지 않으므로 쿠키로 인해 발생하는 취약점이 사라진다.
    3. 트래픽에 대한 부담이 적다. = 1번 과정때문에
    4. REST 서비스로 제공 가능하다 - HTTP와 XML을 이용하여 데이터를 주고받을 수 있다.
    5. Token의 만료기간 설정으로 자동으로 관리된다.

4. 반대로 JWT를 사용한 인증/인가의 한계점은 무언인가?
A : 1. 토큰의 페이로드(payload)에 principal, credients, authorities 3종류를 담고 있는데, 정보가 많아질 수록
        토큰의 길이가 길어져 네트워크에 부하가 올 수 있다.
    2. Payload가 암호화된 것이 아니라 BASE64로 인코딩된 것이기 때문에 payload 탈취시 디코딩하여 정보를 볼 수 있다.
    3. Stateless로 JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 임의로 삭제하는 것이 불가능하다 => 만료기간 설정
    4. JWT 토큰을 클라이언트 측에 저장한다. = 서버에 저장하지 않는다.


# CRUD 기능 구현 시
1. 수정, 삭제 API의 request를 어떤 방식으로 사용했나요? (param, query, body)
A: 공통적으로 id의 경우, param을 이용하여 @PathVariable을 통해 url로 전달하였다.
수정 request의 경우, 사용자로부터 입력받는 데이터가 Memo Entity 생성자와 일치하기 때문에 JSON형태로 받아와
객체로 자동 변환하여 만들어주는 @RequestBody 형태로 사용하였다.
삭제 request의 경우, password만을 넘겨주기 때문에 간단한 Requestparam이나 PathVaraibleMemo을 고려했지만
패스워드가 같은 중요 데이터 값을 url에 표시하는 것이 좋지않아서 json body로 데이터를 넘기도록 하였다.
Entity객체에서 password만을 생성하는 객체가 아니므로, 별도의 Map 객체로 받아서 값을 받아왔다.


2. 어떤 상황에 어떤 방식의 request를 써야하나?
A: 데이터를 조회하는 경우 GET, 데이터를 추가하는 경우 POST, 데이터를 수정하는 경우 PUT, 데이터를 삭제하는 경우 DELETE

3. RESTful한 API를 설계하였나? 어떤 부분이 그렇고, 어떤 부분이 그렇지 않은지
A: Controller, Service, Repository로 3계층을 나누어 Controller는 데이터의 전달, Service는 데이터의 가공, Repository는 데이터베이스의 관리를
담당할 수 있도록 기능들을 분리하여 코드를 작성하였다. 요청받는 url의 형식을 통일하였고, 요청에 맞는 API를 지정하였다.

4. 적절한 관심사 분리를 적용하였나요? (controller, Repository, Service)
A: controller에는 데이터의 전달을 담당하는 기능만, Service에는 데이터의 가공, 로직 수행을 위한 코드만, Repository에는 데이터베이스에서
처리할 수 있는 기능으로 분리하여 코드를 작성하였다.

5. API 명세서
api 명세 이미지 첨부
